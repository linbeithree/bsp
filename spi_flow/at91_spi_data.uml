@startuml
== Data Flow ==

autonumber "<b>[00]"


API -> "driver" :  cyg_spi_at91_bus_t
note right #AAFFFF
	cyg_spi_at91_bus_t {
    //  Upper layer data 
    cyg_spi_bus   spi_bus;                  // Upper layer SPI bus data

    //  Lower layer data 
    cyg_interrupt     spi_interrupt;        // SPI interrupt object
    cyg_handle_t      spi_interrupt_handle; // SPI interrupt handle
    cyg_drv_mutex_t   transfer_mx;          // Transfer mutex
    cyg_drv_cond_t    transfer_cond;        // Transfer condition
    cyg_bool          transfer_end;         // Transfer end flag
    cyg_bool          cs_up;                // Chip Select up flag 
    cyg_vector_t      interrupt_number;     // SPI Interrupt Number
    cyg_addrword_t    base;                 // Base Address of the SPI peripheral
    cyg_uint8         cs_en[4];             // The Configurations state for the CS
    cyg_uint32        cs_gpio[4];           // The GPIO Configurations for the CS
	}
end note

"driver" -> "I/O" :  cyg_spi_bus
note right #AAFFFF
	cyg_spi_bus
	{
		cyg_drv_mutex_t spi_lock;
		#ifdef CYGDBG_USE_ASSERTS
		cyg_spi_device *spi_current_device;
		#endif
		void (*spi_transaction_begin)(cyg_spi_device *);
		void (*spi_transaction_transfer)(cyg_spi_device *, cyg_bool, cyg_uint32, const cyg_uint8 *, cyg_uint8 *, cyg_bool);
		void (*spi_transaction_tick)(cyg_spi_device *, cyg_bool, cyg_uint32);
		void (*spi_transaction_end)(cyg_spi_device *);
		int (*spi_get_config)(cyg_spi_device *, cyg_uint32, void *, cyg_uint32 *);
		int (*spi_set_config)(cyg_spi_device *, cyg_uint32, const void *, cyg_uint32 *);
	} cyg_spi_bus;
end note
@enduml